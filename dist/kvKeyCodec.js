// deno-lint-ignore-file
var S=Object.defineProperty;var p=(t,e)=>S(t,"name",{value:e,configurable:!0});var N=p((t,e)=>{if(typeof e=="bigint"){let n=BigInt(0);if(e===n)t.appendByte(20);else{let o=e<n,r=(o?-e:e).toString(16),i=K((r.length%2===1?"0":"")+r),s=i.length;if(s>255)throw Error("Tuple encoding does not support bigints larger than 255 bytes.");if(o)for(let a=0;a<i.length;a++)i[a]=~i[a];s<=8?t.appendByte(20+(o?-s:s)):s<256&&(t.appendByte(o?11:29),t.appendByte(o?s^255:s)),t.appendBuffer(i)}}else throw new TypeError("Item must be BigInt")},"encodeBigInt");function I(t,e,n){let{p:o}=e;if(n>=11&&n<=29){let r=n-20,i=Math.abs(r);return e.p+=i,n===20?0:R(t,o,i,r<0)}else throw new TypeError(`Invalid tuple data: code ${n} ('${t}' at ${e})`)}p(I,"decodeBigInt");function R(t,e,n,o){let r=BigInt(0),i=0;for(let s=n-1;s>=0;--s){let a=t[e+s];o&&(a=~a&255),r+=BigInt(a)<<BigInt(i),i+=8}return o?-r:r}p(R,"decodeIt");function K(t){let e=new Uint8Array(Math.ceil(t.length/2));for(let n=0;n<e.length;n++)e[n]=parseInt(t.substr(n*2,2),16);return e}p(K,"fromHexString");function b(t){return typeof t=="bigint"}p(b,"isBigInt");function D(t){let e=new Uint8Array(8);return M(e,t,0),O(e,!0)}p(D,"encodeDouble");function U(t){return O(t,!1),F(t,0)}p(U,"decodeDouble");function M(t,e,n){e=+e,n=n>>>0,k(t,e,n)}p(M,"writeDoubleBE");var B=8;function k(t,e,n){let o=52,r,i,s,a=B*8-o-1,h=(1<<a)-1,c=h>>1,f=0,y=B-1,u=-1,L=e<0||e===0&&1/e<0?1:0;for(e=Math.abs(e),isNaN(e)||e===1/0?(i=isNaN(e)?1:0,r=h):(r=Math.floor(Math.log(e)/Math.LN2),e*(s=Math.pow(2,-r))<1&&(r--,s*=2),r+c>=1?e+=f/s:e+=f*Math.pow(2,1-c),e*s>=2&&(r++,s/=2),r+c>=h?(i=0,r=h):r+c>=1?(i=(e*s-1)*Math.pow(2,o),r=r+c):(i=e*Math.pow(2,c-1)*Math.pow(2,o),r=0));o>=8;t[n+y]=i&255,y+=u,i/=256,o-=8);for(r=r<<o|i,a+=o;a>0;t[n+y]=r&255,y+=u,r/=256,a-=8);t[n+y-u]|=L*128}p(k,"ieeeWrite");function G(t,e,n){let r,i,s=B*8-52-1,a=(1<<s)-1,h=a>>1,c=-7,f=n?B-1:0,y=n?-1:1,u=t[e+f];for(f+=y,r=u&(1<<-c)-1,u>>=-c,c+=s;c>0;r=r*256+t[e+f],f+=y,c-=8);for(i=r&(1<<-c)-1,r>>=-c,c+=52;c>0;i=i*256+t[e+f],f+=y,c-=8);if(r===0)r=1-h;else{if(r===a)return i?NaN:(u?-1:1)*(1/0);i=i+Math.pow(2,52),r=r-h}return(u?-1:1)*i*Math.pow(2,r-52)}p(G,"ieeeRead");function F(t,e){return e=e>>>0,G(t,e,!1)}p(F,"readDoubleBE");function O(t,e){if(e&&(t[0]&128)===128||!e&&!(t[0]&128))for(let n=0;n<t.length;n++)t[n]=~t[n];else t[0]^=128;return t}p(O,"adjustFloat");var Z=p((t,e)=>{if(e===void 0)throw new TypeError("Packed element cannot be undefined");if(e===null)t.appendByte(0);else if(e===!1)t.appendByte(38);else if(e===!0)t.appendByte(39);else if(e.constructor===Uint8Array||typeof e=="string"){let n;typeof e=="string"?(n=new TextEncoder().encode(e),t.appendByte(2)):(n=e,t.appendByte(1));for(let o=0;o<n.length;o++){let r=n[o];t.appendByte(r),r===0&&t.appendByte(255)}t.appendByte(0)}else{if(Array.isArray(e))throw new Error("Nested Tuples are not supported!");if(typeof e=="number")t.appendByte(33),t.appendBuffer(D(e));else if(b(e))N(t,e);else throw new TypeError("Packed items must be an array!")}},"encodeKey");function $(t){if(t===void 0||Array.isArray(t)&&t.length===0)return new Uint8Array(0);if(!Array.isArray(t))throw new TypeError("pack must be called with an array");let e=new l;for(let n=0;n<t.length;n++)Z(e,t[n]);return e.extract()}p($,"packRawKey");function v(t){return $(t)}p(v,"pack");function z(t,e){let n=t[e.p++],{p:o}=e;switch(n){case 38:return!1;case 39:return!0;case 1:{let r=new l;for(;o<t.length;o++){let i=t[o];if(i===0){if(o+1>=t.length||t[o+1]!==255)break;o++}r.appendByte(i)}return e.p=o+1,r.extract()}case 2:{let r=new l;for(;o<t.length;o++){let s=t[o];if(s===0){if(o+1>=t.length||t[o+1]!==255)break;o++}r.appendByte(s)}return e.p=o+1,new TextDecoder("utf-8").decode(r.extract().buffer)}case 33:{let r=new Uint8Array(8);for(let i=0;i<8;i++)r[i]=t[o+i];return e.p+=8,U(r)}default:{if(n>=11||n<=29)return I(t,e,n);throw new TypeError(`Invalid KvKey data: code ${n} ('${t}' at ${e})`)}}}p(z,"decodeKey");function se(t){let e={p:0},n=[];for(;e.p<t.byteLength;)n.push(z(t,e));return n}p(se,"unpack");var l=class{constructor(e=32768){this.insertionPoint=0;this.size=e,this.flexBuf=new ArrayBuffer(e,{maxByteLength:e*1e3}),this.accumulator=new Uint8Array(this.flexBuf)}appendByte(e){this.requires(1),this.accumulator[this.insertionPoint++]=e}appendBuffer(e){let n=e.byteLength;this.requires(n),this.accumulator.set(new Uint8Array(e),this.insertionPoint),this.insertionPoint+=n}requires(e){if(this.accumulator.length<this.insertionPoint+e){let n=this.accumulator.byteLength;for(;n<this.insertionPoint+e;)n+=this.size*2;this.flexBuf.resize(n)}}extract(){return this.accumulator.slice(0,this.insertionPoint)}};p(l,"Accumulator");export{l as Accumulator,v as pack,se as unpack};
